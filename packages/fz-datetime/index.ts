const _isAlpha = (char: string) => /^[a-zA-Z]$/.test(char);
const _isDigit = (char: string) => /^[0-9]$/.test(char);

const _isUnixTimestampSec = (s: string) => {
	const n = Number(s);
	return (
		Number.isSafeInteger(n) &&
		Math.abs(n) >= 0 &&
		Math.abs(n) <= 9_999_999_999
	);
};

const _isUnixTimestampMs = (s: string) => {
	const n = Number(s);
	return (
		Number.isSafeInteger(n) &&
		Math.abs(n) >= 0 &&
		Math.abs(n) <= 9_999_999_999_999
	);
};

const _isUnixTimestamp = (s: string) =>
	_isUnixTimestampSec(s) || _isUnixTimestampMs(s);

const _isISO8601 = (s: string) => true;
const _isISO8601WithTimezone = (s: string) => true;
const _isISO8601WithOffset = (s: string) => true;

enum FzDatetimeTokenType {
	NUMBER,
	HOUR,
	MINUTE,
	SECOND,
	AM,
	PM,
	YEAR,
	MONTH,
	DAY,
	WEEK,
	EOF,
}

type FzDatetimeTokenvalue = string | number;

type FzDatetimeToken = {
	tok_type: FzDatetimeTokenType;
	tok_value?: FzDatetimeTokenvalue;
};

const KEYWORDS: Record<string, FzDatetimeTokenType> = {
	year: FzDatetimeTokenType.YEAR,
	yr: FzDatetimeTokenType.YEAR,
	month: FzDatetimeTokenType.MONTH,
	mo: FzDatetimeTokenType.MONTH,
	day: FzDatetimeTokenType.DAY,
	d: FzDatetimeTokenType.DAY,
	week: FzDatetimeTokenType.WEEK,
	wk: FzDatetimeTokenType.WEEK,
	hour: FzDatetimeTokenType.HOUR,
	hr: FzDatetimeTokenType.HOUR,
	h: FzDatetimeTokenType.HOUR,
	minute: FzDatetimeTokenType.MINUTE,
	min: FzDatetimeTokenType.MINUTE,
	m: FzDatetimeTokenType.MINUTE,
	second: FzDatetimeTokenType.SECOND,
	sec: FzDatetimeTokenType.SECOND,
	s: FzDatetimeTokenType.SECOND,
	am: FzDatetimeTokenType.AM,
	pm: FzDatetimeTokenType.PM,
};

const fzDatetimeScan = (src: string): FzDatetimeToken[] => {
	let current = 0;
	const tokens: FzDatetimeToken[] = [];

	const isEof = (): boolean => current >= src.length;
	const advance = (): string => src.charAt(current++);
	const peek = (): string => (isEof() ? "\0" : src.charAt(current));
	const addToken = (
		type: FzDatetimeTokenType,
		value?: FzDatetimeTokenvalue,
		text?: string,
	) => {
		tokens.push({ tok_type: type, tok_value: value ?? text });
	};

	while (!isEof()) {
		const start = current;
		const char = advance();

		const allowedDelimeters = [" ", "\r", "\t", "\n"];

		switch (true) {
			case allowedDelimeters.includes(char):
				break;

			case _isDigit(char):
				while (_isDigit(peek())) {
					advance();
				}
				const numValue = Number(src.substring(start, current));
				addToken(FzDatetimeTokenType.NUMBER, numValue);
				break;

			case _isAlpha(char):
				while (_isAlpha(peek())) {
					advance();
				}
				const text = src.substring(start, current).toLowerCase();
				const tokenType = KEYWORDS[text];

				if (tokenType !== undefined) {
					addToken(tokenType, text);
				}
				// Unknown identifiers are ignored.
				break;

			// Unrecognized characters are ignored by default.
			default:
				break;
		}
	}

	tokens.push({ tok_type: FzDatetimeTokenType.EOF });
	return tokens;
};

type PartialDatetime = {
	year?: number;
	month?: number;
	day?: number;
	hour?: number;
	minute?: number;
	second?: number;
};

type FzDatetimeParseOutput = PartialDatetime;

/**
 * Parses a sequence of tokens into a structured date-time object.
 * * Rules:
 * 1. If a NUMBER token is followed by an identifier (YEAR, MONTH, etc.),
 * the number is explicitly assigned to that identifier.
 * 2. If an identifier is assigned multiple times, only the first assignment is kept.
 * 3. NUMBER tokens not followed by an identifier are considered "unassociated" and
 * are assigned to the remaining empty slots in the default order:
 * year, month, day, hour, minute, second.
 *
 * @param tokens The array of tokens generated by the scanner.
 * @returns A ParsedDateTime object with the extracted values.
 */
function fzDatetimeParse(tokens: FzDatetimeToken[]): FzDatetimeParseOutput {
	const result: FzDatetimeParseOutput = {};

	const unassociatedNumbers: number[] = [];

	const tokenTypeToKey: Partial<
		Record<FzDatetimeTokenType, keyof FzDatetimeParseOutput>
	> = {
		[FzDatetimeTokenType.YEAR]: "year",
		[FzDatetimeTokenType.MONTH]: "month",
		[FzDatetimeTokenType.DAY]: "day",
		[FzDatetimeTokenType.HOUR]: "hour",
		[FzDatetimeTokenType.MINUTE]: "minute",
		[FzDatetimeTokenType.SECOND]: "second",
	};

	for (let i = 0; i < tokens.length; i++) {
		const currentToken = tokens[i];

		// We only care about number tokens in this loop
		if (currentToken.tok_type !== FzDatetimeTokenType.NUMBER) {
			continue;
		}

		const nextToken = tokens[i + 1];
		const numberValue = currentToken.tok_value as number;

		// Check if the next token is a valid identifier (YEAR, MONTH, etc.)
		const associatedKey =
			nextToken ? tokenTypeToKey[nextToken.tok_type] : undefined;

		if (associatedKey) {
			// Rule 1 & 2: If the slot is empty, assign the number.
			if (typeof result[associatedKey] === "undefined") {
				result[associatedKey] = numberValue;
			}
			i++;
		} else {
			unassociatedNumbers.push(numberValue);
		}
	}

	const defaultOrder: (keyof FzDatetimeParseOutput)[] = [
		"year",
		"month",
		"day",
		"hour",
		"minute",
		"second",
	];

	for (const key of defaultOrder) {
		if (unassociatedNumbers.length === 0) {
			break;
		}
		if (typeof result[key] === "undefined") {
			result[key] = unassociatedNumbers.shift()!;
		}
	}
	return result;
}

type FzDatetimeOptions = {
	coerce?: Date[];
	/** If true, enables parsing of Unix timestamps (e.g., number of milliseconds since epoch). */
	parseUnix?: boolean;
	/** If true, enables parsing of ISO 8601 strings. */
	parseISO?: boolean;
	/** If true, enables parsing of full named months (e.g., "January" or "Jan"). */
	parseNamedMonths?: boolean;
	/** The maximum number of suggestions to return. If -1, returns all suggestions. */
	maxSuggestionsCount?: number;
};

type FzDatetime = {
	parse: (s: string) => { score: number; date: Date }[];
};

/**
 * Initialize a new FzDatetime instance.
 * @param opts - The options for the FzDatetime instance.
 * ---
 * SCORING SYSTEM
 * 1. Each predicate (like `year`, `month`, `day`, etc.) is assigned 5 units of score. If the predicate is not found, it is assigned 0 units.
 * 2. For each prediction rules applied, the score of the predicates is reduced by 1 unit.
 */
function fzDatetime(opts?: FzDatetimeOptions): FzDatetime {
	const {
		coerce = [new Date()],
		parseUnix = true,
		parseISO = true,
		parseNamedMonths = true,
	} = opts || {};

	let { maxSuggestionsCount = 5 } = opts || {};

	if (maxSuggestionsCount < -1) maxSuggestionsCount = 5;

	const predicates = ["year", "month", "day", "hour", "minute", "second"];
	const predicateScore = 5;

	const parse: FzDatetime["parse"] = s => {
		const firstDate = fzDatetimeParse(fzDatetimeScan(s));
		const firstScore = predicates.reduce(
			(acc, p) => acc + (firstDate[p] ? predicateScore : 0),
			0,
		);
		const firstPrediction = {
			score: firstScore,
			date: firstDate,
		};

		// TODO: pick years from `coerce` array
		if (
			firstPrediction.date.year &&
			firstPrediction.date.year.toString().length === 2
		) {
			const year = 2000 + Number(firstPrediction.date.year);
			firstPrediction.date.year = year;
			firstPrediction.score--;
		}

		const predictions = [firstPrediction];

		// apply predictions
		if (!firstPrediction.date.day && firstPrediction.date.month) {
			predictions.push({
				score: firstPrediction.score - 1,
				date: {
					...firstPrediction,
					day: firstPrediction.date.month,
					month: undefined,
				},
			});
		} else if (
			firstPrediction.date.day &&
			firstPrediction.date.day <= 12 &&
			firstPrediction.date.day !== firstPrediction.date.month
		) {
			predictions.push({
				score: firstPrediction.score - 1,
				date: {
					...firstPrediction,
					month: firstPrediction.date.day,
					day: firstPrediction.date.month,
				},
			});
		}

		let coercedDates = predictions
			.map(p => {
				return coerce.map(d => {
					// `getMonth` returns a zero-based index, so we need to add 1 to get the correct month.
					const month = (p.date.month || d.getMonth() + 1) - 1;
					return {
						score: p.score,
						date: {
							year: p.date.year || d.getFullYear(),
							month,
							day: p.date.day || d.getDate(),
							hour: p.date.hour || d.getHours(),
							minute: p.date.minute || d.getMinutes(),
							second: p.date.second || d.getSeconds(),
						},
					};
				});
			})
			.flat(1);

		/*const transformedDates = transformations.reduce(
			(acc, fn) => fn(acc),
			[date],
		);*/

		const transformedDates = coercedDates.sort((a, b) => b.score - a.score);

		const dates = transformedDates.map(({ score, date }) => {
			const { year, month, day, hour, minute, second } = date;
			return {
				score,
				date: new Date(year, month, day, hour, minute, second),
			};
		});

		if (maxSuggestionsCount === -1) return dates;
		return dates.slice(0, maxSuggestionsCount);
	};
	return { parse };
}

export { fzDatetime };
